## HTTP Headers
|Header Name  |Required   |Description|
|-------------|-----------|-----------|
|Api-Key      |Yes        |This is the partner API key. Refer to the Apigee portal for more details. This is the API key is used to identify the partner and to use the ConnectPay API.|
|Timestamp    |Yes        |Request initiation UTC timestamp, formatted as Epoch time. The value is in milliseconds. Sample value format is 1499961987232|
|Authorization|Optional   |Authorization header is required to have the "HMAC" string capitalized and followed by one space followed by the calculated hmac signature. For request generated through Server: Authorization: - HMAC . "HMAC " followed by the Encrypted payload as signature, shown below:|
|Content-Type |Yes        |application/JSON|
|Client-Token |Optional   |This is OAuth token generated by /v1/security/createsessiontoken ConnectPay API service. This would be sent in instead of Authorization by the SDK.|
|corelationID |Conditional (For merchants who opt for long lived public key)|For MAS to ConnectPayAPI server calls, MAS need to provide reference transaction id in the service request header for transaction tracking. If MAS fails to provide transaction id, then ConnectPayAPI will generate separate correlationID for each flow and each end-to-end transaction will have separate transaction id for each request in the transaction. Considering that one business scenario consists of multiple api calls, the reference transaction id of the first call should be populated in the subsequent calls.|
|isSecureCall |Conditional (For merchants who opt for long lived public key)|For MAS to ConnectPayAPI server calls, MAS need to provide the header with value ‘Y’. For SDK/App to ConnectPayAPI calls, the header is not required. If present, it should have value ‘N’ Any values other than Y/N will be treated as configuration error, and MAS will receive BAD REQUEST.|

### Sample Header
```
"Content-Type" : "application/json"
"Api-Key" : "YMgw8VSrYMG6WTIUnoUUGv7hF9Aqh3EO"
"Timestamp": "1607368688646"
"Authorization" : "HMAC W5X9NAlPgSNsfQX55fXbXrk3arzL6KxcCTA6SrnxL+U="
"Client-Token" : "IXwY1BYpvWpoGzete43AdLzXSdj4"
```
## How to generate HMAC Signature

### Description
The HMAC signature is used in all calls made through our API and is a necessary step to receive a successful response from the system.

### High Level Flow
1. Get the apikey or the merchant's ConnectPay FirstAPI key
2. Get and save the current UTC timestamp, to the millisecond
3. Concatenate the two paramters to output apikey:timestamp
4. Get the request payload or the actual content passed as a post request
5. Create a hash of the payload using SHA256
6. Encode the hash using Base64 to create base64ofPayloadDigest
7. Concatenate apikey:timestamp with base64ofPayloadDigest to create apikey:timestamp:base64ofPayloadDigest
8. Get the apiSecret or the merchant's ConnectPay FirstAPI secret
9. Create the HMAC value using HMAC SHA256, apikey:timestamp:base64ofPayloadDigest, and the apiSecret as the secret for the HMAC SHA256 calculation
10. Encode the new HMAC value using Base64 to create the signature
11. Append the signature to HMAC followed by a space to create "HMAC Signature"
12. The "Authorization" header = HMAC signature

Below is sample code on how to create the "Authorization" header:
```java
import java.security.MessageDigest;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;
public class HmacUtil {
    private static final String CT_CLN = ":";
    private static final String MD_ALG = "SHA-256";
    private static final String HMAC_ALG = "HmacSHA256";
    public static String generateHmac(String apiKey,
    String apiSecret,String epochTimestamp, String payload) throws Exception {
        byte[] hash = MessageDigest.getInstance(MD_ALG).digest(payload.getBytes());
        String encPyld = Base64.encodeBase64String(hash);
        String messageToSign = apiKey + CT_CLN + epochTimestamp + CT_CLN + encPyld;
        Mac hmac = Mac.getInstance(HMAC_ALG);
        SecretKeySpec key = new SecretKeySpec(apiSecret.getBytes(), HMAC_ALG);
        hmac.init(key);
        return Base64.encodeBase64String(hmac.doFinal(messageToSign.getBytes()));
    }
}
```
## Encryption & Decryption Methodologies 
Most of the ConnectPay APIs need to be encrypted prior to making a request. The methodologies are discussed below with example code on the actual methods in Java. We will use these methods later in order to generate and encrypt the payloads.

<details>
<summary>1. AES Key and IV Generation</summary>
<br>
<span style="font-size: 1.25em; color: var(--bs-heading-color)">
AES Key
</span> 

The AES Key generated must be size 256-bit in order for the Fiserv systems to decrypt the request payload. <p>

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
IV
</span> 

The IV generated must be size 96-bit in order for the Fiserv systems to decrypt the request payload.

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
Key Generator
</span> 

The AES Key and IV will be used to encrypt the actual request payload. Below is sample code on how to generate the merchant's AES key and IV:
```java
private static final char[] HEX_ARRAY = "0123456789abcdef".toCharArray(); 

private String randomHexString(int size) { 
    SecureRandom random = new SecureRandom(); 
    byte[] iv = new byte[count / 8]; 
    random.nextBytes(iv); 
    return bytesToHex(iv); 
} 

public static String bytesToHex(byte[] bytes) { 
    char[] hexChars = new char[bytes.length * 2]; 
    for (int j = 0; j < bytes.length; j++) { 
        int v = bytes[j] & 0xFF; 
        hexChars[j * 2] = HEX_ARRAY[v >>> 4]; 
        hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F]; 
    } 
    return new String(hexChars); 
} 
```
</details>

<details>
<summary>2. AES Encryption and Decryption</summary>
<br>
The merchant must implement methods for AES encryption in order to encrypt the payload prior to making a call. <p>

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
AES Specification
</span>

| Type | Value            | 
|------|------------------|
|ALGO  |AES               | 
|CIPHER| AES/GCM/NoPadding|

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
AES Encryption
</span> 

AES Encryption will be used to encrypt the actual payload using the AES Key and IV generated before. Below is sample code on how to encrypt using AES:
```java
public class AesUtil {
    private static final String ALGO = "AES";
    private Cipher cipher = null;
    private SecretKey secretKey = null;
    private String initializationVector = null;
    private String correlationId = null;

    public static final int GCM_TAG_LENGTH_BIT = 128;
    private static final int IV_LENGTH_BYTE = 12;

    /**
    * Initialize cipher with IV and secret key
    */
    public void init(String encKey, String initializationVector, String correlationId) throws Exception {
        try {
            cipher = Cipher.getInstance(PartnerAlgo.AES_GCM_NoPadding.getValue());
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            LOG.error("Exception in AesUtil.init {}", e);
            throw e;
        }
        this.secretKey = generateKey(encKey);
        this.initializationVector = initializationVector;
        this.correlationId = correlationId;
    }

    /**
    * encryption with secret key, IV and salt (IV value)
    */
    public String encrypt(String clearText, String correlationId) throws Exception {
        if (this.correlationId == null)
            this.correlationId = correlationId;
        try {
            byte[] encrypted = doFinal(Cipher.ENCRYPT_MODE, secretKey, initializationVector,
                clearText.getBytes("UTF-8"));
            byte[] IV_BYTES = hex(initializationVector);
            byte[] cipherTextWithIv = ByteBuffer.allocate(IV_BYTES.length + encrypted.length).put(IV_BYTES)
                .put(encrypted).array();
            return base64(cipherTextWithIv);
        } catch (UnsupportedEncodingException e) {
            LOG.error("Exception in AesUtil.encrypt {}", e);
            throw e;
        } catch (Exception e) {
            LOG.error("Exception in AesUtil.encrypt {}", e);
            throw e;
        }
    }

    private SecretKey generateKey(String encKey) {
        try {
            SecretKey key = new SecretKeySpec(hex(encKey), ALGO);
            return key;
        } catch (NumberFormatException | DecoderException e) {
            LOG.error("Exception in AesUtil.generateKey {}", e);
            return null;
        }
    }

    private byte[] doFinal(int encryptMode, SecretKey key, String iv, byte[] bytes) throws Exception {
        cipher.init(encryptMode, key, new GCMParameterSpec(GCM_TAG_LENGTH_BIT, hex(iv)));
        return cipher.doFinal(bytes);
    }
}
```

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
AES Decryption
</span>

The AES decryption method will be used to decode the response payload using the AES key and IV once the process is complete. Below is sample code on how to decrypt using RSA:

```java
public class AesUtil {
    private static final String ALGO = "AES";
    private Cipher cipher = null;
    private SecretKey secretKey = null;
    private String initializationVector = null;
    private String correlationId = null;

    public static final int GCM_TAG_LENGTH_BIT = 128;
    private static final int IV_LENGTH_BYTE = 12;
    
    /**
    * Initialize cipher with IV and secret key
    */
    public void init(String encKey, String initializationVector, String correlationId) throws Exception {
        try {
            cipher = Cipher.getInstance(PartnerAlgo.AES_GCM_NoPadding.getValue());
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
            LOG.error("Exception in AesUtil.init {}", e);
            throw e;
        }
        this.secretKey = generateKey(encKey);
        this.initializationVector = initializationVector;
        this.correlationId = correlationId;
    }

    /**
    * Decryption with secret key, IV and salt (IV value)
    */
    public String decrypt(String ciphertext) throws Exception {
        try {
            ByteBuffer buffer = ByteBuffer.wrap(base64(ciphertext));
            byte[] iv = new byte[IV_LENGTH_BYTE];
            buffer.get(iv);
            byte[] extractedCipherText = new byte[buffer.remaining()];
            buffer.get(extractedCipherText);
            byte[] decrypted = doFinal(Cipher.DECRYPT_MODE, secretKey, initializationVector, extractedCipherText);
            return new String(decrypted, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            LOG.error("Exception in AesUtil.decrypt {}", e);
            throw e;
        } catch (Exception e) {
            LOG.error("Exception in AesUtil.decrypt {}", e);
            throw e;
        }
    }

    private SecretKey generateKey(String encKey) {
        try {
            SecretKey key = new SecretKeySpec(hex(encKey), ALGO);
            return key;
        } catch (NumberFormatException | DecoderException e) {
            LOG.error("Exception in AesUtil.generateKey {}", e);
            return null;
        }
    }

    private byte[] doFinal(int encryptMode, SecretKey key, String iv, byte[] bytes) throws Exception {
        cipher.init(encryptMode, key, new GCMParameterSpec(GCM_TAG_LENGTH_BIT, hex(iv)));
        return cipher.doFinal(bytes);
    }
}
```
</details>

<details>
<summary>3. RSA Encryption and Decryption</summary>
<br>
The merchant must implement RSA Encryption in order to encrypt the AES key and IV using the RSA "publicKey" generated from the "Create Session Token" API.

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
RSA Specification
</span>

| Type | Value                               | 
|------|-------------------------------------|
|ALGO  |RSA                                  | 
|CIPHER|RSA/None/OAEPwithSHA512AndMGF1Padding|

<span style="font-size: 1.25em; color: var(--bs-heading-color)">
RSA Encryption
</span>

RSA will be used to encrypt Components X and Y which are the AES Key and IV respectively. These are encrypted using the RSA public key obtained from the Create Session Token API. Below is sample code on how to encrypt using RSA:
```java
private static final String ALGORITHM = "RSA";  
public static String encrypt(byte[] publicKey, String inputData, String rsaAlgoType) throws Exception { 

    LOG.info("Start Encrypt"); 

    // Provider added for new algorithm (RSA/None/OAEPWithSHA512AndMGF1Padding) support 
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider()); 

    X509EncodedKeySpec ks = new X509EncodedKeySpec(publicKey); 
    KeyFactory kf = KeyFactory.getInstance(ALGORITHM); 
    PublicKey key = kf.generatePublic(ks); 
    Cipher cipher = getCipher(rsaAlgoType); 
    cipher.init(Cipher.ENCRYPT_MODE, key); 
    byte[] cryptogram = cipher.doFinal(inputData.getBytes()); 
    final String encValue = new String(Base64.encodeBase64(cryptogram)); 
    return encValue; 
} 
```
<span style="font-size: 1.25em; color: var(--bs-heading-color)">
RSA Decryption
</span>

Below is sample code on how to decrypt using RSA however, the Merchant may not need decryption methods for RSA since the Fiserv backend will decrypt the request payload in order to process the request. The merchant may still want to decrypt the request payload based on a variety of different factors. Below is a sample code on how to decrypt using RSA:
```java
private static final String ALGORITHM = "RSA";  
public static String decrypt(byte[] privateKey, String inputData,String rsaAlgoType) throws Exception { 
    LOG.info("Start Decrypt"); 
    PrivateKey key = KeyFactory.getInstance(ALGORITHM).generatePrivate(new PKCS8EncodedKeySpec(privateKey)); 
    Cipher cipher = getCipher(rsaAlgoType); 
    cipher.init(Cipher.DECRYPT_MODE, key); 
    byte[] decryptedBytes = cipher.doFinal(Base64.decodeBase64(inputData)); 
    LOG.info("End Decrypt"); 
    return new String(decryptedBytes, "UTF-8"); 
} 
```
</details>

>After completing this setup please proceed to your appropriate integration to continue: 
[API Integration](https://github.com/Fiserv/connect-pay/blob/develop/documentation/implementationguide.md)
<br>
[SDK Integration](https://github.com/Fiserv/connect-pay/blob/develop/documentation/sdkimplementationguide.md)